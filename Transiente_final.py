# -*- coding: utf-8 -*-
"""Trabalho TransCal 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IlwkXr3i_XK_tjCK98-amPi7cdvFF1vs
"""

#importação de bibliotecas
import numpy as np
import time
import matplotlib.pyplot as plt

r = np.arange(0,100,1)

def obtem_dados():
  """

  Returns: [[kf,kc],[rhof,rhoc],[cpf,cpc],[alfaf,alfac],[rf,rc],[nf,nc],[delta_rf,delta_rc],dt,ti,to,sno,b]

  """

  print("Para todos os dados que inserir e que possuam casas decimais, utilize o ponto como dígito separador.")

  mensagem_de_erro_input = "Você deve inserir um número, tente novamente. Lembre que caso haja casas decimais, estas devem ser separadas da parte inteira por um ponto."

  #obtendo os dados para o problema
  while True:
    kf_str = input("Qual a condutividade térmica do combustível, em [W/mK]? ")
    try:
      kf = float(kf_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    kc_str = input("Qual a condutividade térmica do revestimento, em [W/mK]? ")
    try:
      kc = float(kc_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    rhof_str = input("Qual a densidade do combustível, em [kg/m³]? ")
    try:
      rhof = float(rhof_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    rhoc_str = input("Qual a densidade do revestimento, em [kg/m³]? ")
    try:
      rhoc = float(rhoc_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    cpf_str = input("Qual o calor específico à pressão constante do combustível, em [J/kg K]? ")
    try:
      cpf = float(cpf_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    cpc_str = input("Qual o calor específico à pressão constante do revestimento, em [J/kg K]? ")
    try:
      cpc = float(cpc_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  alfaf , alfac = kf/(rhof*cpf) , kc/(rhoc*cpc)

  f = True
  c = True

  while f or c:

    while True:
      rf_str = input("Qual o tamanho do raio do combustível, em milímetros? ")
      try:
        rf = float(rf_str)/1000
      except:
        print(mensagem_de_erro_input)
      else:
        break

    while True:
      nf_str =  input("Qual o número de pontos de malha para a região de combustível? ")
      try:
        nf = int(nf_str)
      except:
        print(mensagem_de_erro_input)
      else:
        break

    while True:
      ec_str = input("Qual a espessura do revestimento, em milímetros? ")
      try:
        rc = float(ec_str)/1000 + rf
      except:
        print(mensagem_de_erro_input)
      else:
        break

    while True:
      nc_str = input("Qual o número de pontos de malha para a região de revestimento? ")
      try:
        nc = int(nc_str)
      except:
        print(mensagem_de_erro_input)
      else:
        break

    delta_rf , delta_rc = rf/(nf-1) , rc/(nc-1)

    while True:
      dt_str = input("Qual será o passo de tempo, em segundos? ")
      try:
        dt = float(dt_str)
      except:
        print(mensagem_de_erro_input)
      else:
        break

    if ((alfaf*dt)/(delta_rf**2)) < 0.5:
      f = False
      if (alfac*dt)/(delta_rc**2) < 0.5:
        c = False
      else:
        dt_f_max = (delta_rf**2)/(2*alfaf)
        print("O passo de tempo está muito grande, refine ele para conseguir uma solução estável para o problema. O passo máximo aceitável, com os dados que você passou, é: " + str(dt_f_max) +".")
    else:
      dt_c_max = (delta_rc**2)/(2*alfac)
      print("O passo de tempo está muito grande, refine ele para conseguir uma solução estável para o problema. O passo máximo aceitável, com os dados que você passou, é: " + str(dt_c_max) +".")

  while True:
    ti_str = input("Qual a temperatura inicial, em graus celsius? ")
    try:
      ti = float(ti_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    to_str = input("Qual a temperatura na superfície externa do revestimento quando o sistema está em regime permanente? ")
    try:
      to = float(to_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    sno_str = input("Qual o valor de Sno (a geração de calor no centro da esfera), em [W/m³]? ")
    try:
      sno = float(sno_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  while True:
    b_str = input("Qual o valor do coeficiente b da distribuição da geração de calor? ")
    try:
      b = float(b_str)
    except:
      print(mensagem_de_erro_input)
    else:
      break

  return [[kf,kc],[rhof,rhoc],[cpf,cpc],[alfaf,alfac],[rf,rc],[nf,nc],[delta_rf,delta_rc],dt,ti,to,sno,b]


def novo_ui(alfaf,dt,rf,delta_rf,u_m,u_i,u_p,i,rhof,cpf,sno=1,b=1):
  """
  Calcula o novo valor de u(i) para a geração n+1
  Args:
    alfaf: difusividade térmica do combustível
    dt: passo de tempo
    rf: raio do combustível
    delta_rf: tamanho da malha para o combustível
    u_m: valor de u(i-1) da geração n
    u_i: valor de u(i) da geração n
    u_p: valor de u(i+1) da geração n
    i: posição i
    rhof: densidade do combustível
    cpf: calor sensível à pressão CTE do combustível
    sno: valor da geração de calor no centro do combustível
    b: coeficiente da parábola para o termo de geração de calor
  """

  #termo de difusão térmica:
  difusao = (alfaf*dt/delta_rf)*(((u_p-2*u_i+u_m)/delta_rf)+((u_p-u_m)/(i*delta_rf)))

  #termo de fonte de calor:
  fonte = ((dt*sno)/(rhof*cpf))*(1+b*((i*delta_rf)/rf)**2)

  #u(i) da geração nova:
  novo_ui = u_i + difusao + fonte

  return novo_ui


def novo_vi(alfac,dt,rf,rc,delta_rc,v_m,v_i,v_p,i,nf):
  """
  Calcula o novo valor de v(i) para a geração n+1
  Args:
    alfac: difusividade térmica do revestimento
    dt: passo de tempo
    rc: raio do revestimento
    delta_rc: tamanho da malha para o revestimento
    v_m: valor de v(i-1) da geração n
    v_i: valor de v(i) da geração n
    v_p: valor de v(i+1) da geração n
    i: posição i
    nf: número de pontos de malha para o combustível
  """

  rci = rf + (i - nf) * delta_rc

  #termo de difusão térmica:
  difusao = (alfac*dt/delta_rc)*(((v_p-2*v_i+v_m)/delta_rc)+((v_p-v_m)/(rci)))

  #v(i) da geração nova:
  novo_vi = v_i + difusao

  return novo_vi


def main(t,caso=False):
  """

  Args:
    t: tempo no qual para o qual a função será calculada.
  """
  
  gravador = []
  
  if caso == True: #caso em que o usuário quer adicionar os próprios parâmetros
    [[kf,kc],[rhof,rhoc],[cpf,cpc],[alfaf,alfac],[rf,rc],[nf,nc],[delta_rf,delta_rc],dt,ti,to,sno,b] = obtem_dados()

  if caso == False: #caso default
    [[kf,kc],[rhof,rhoc],[cpf,cpc],[alfaf,alfac],[rf,rc],[nf,nc],[delta_rf,delta_rc],dt,ti,to,sno,b] = [[7,237],[10970,2700],[240,900],[2.6587663324217565e-06,9.7530864197530864197530864197531e-5],[7e-2,1e-1],[71,30],[1e-3,1e-3],4e-3,25,280,1e6,2]
  
  start_time = time.time()
  
  #iniciando a malha com a condição inicial
  malha = (np.ones(nf + nc - 1) * ti).tolist()

  #número de iterações:
  ncontas = round(t / dt)

  for n in range(ncontas): #tempo

    if ((n * dt) == 30) or ((n * dt) == 10) or ((n * dt) == 20) or ((n * dt) == 40) or ((n * dt) == 50):
      vetor = malha.copy()
      gravador.append(vetor)
      tempo = str(n*dt)
      plt.plot(r,vetor,label = tempo + ' s')
    
    if ((n * dt) == 60) or ((n * dt) == 120) or ((n * dt) == 240) or ((n * dt) == 360) or ((n * dt) == 480) or ((n * dt) == 600) or ((n * dt) == 1800):
      vetor = malha.copy()
      gravador.append(vetor)
      tempo = str(n*dt/60)
      plt.plot(r,vetor,label = tempo + ' min')
      
    if ((n * dt) % 3600 == 0) and ((n*dt) < (3.5*3600)): #grava o vetor temperatura de 1 em 1 hora
      vetor = malha.copy()
      gravador.append(vetor)
      tempo = str(n*dt/3600)
      if (n*dt) != float(0):
        plt.plot(r,vetor,label = tempo + ' h')
      else:
        plt.plot(r,vetor,label = 'Instante inicial')

    if ((n * dt) % (4*3600) == 0): #grava o vetor temperatura de 4 em 4 horas
      vetor = malha.copy()
      gravador.append(vetor)
      tempo = str(n*dt/3600)
      if (n*dt) != float(0):
        plt.plot(r,vetor,label = tempo + ' h')
    
    for i in range(len(malha)): #espaço

      if i == 0:
        malha[i] = malha[i+1]

      if (i >= 1) and (i <= (nf - 2)):
        u_m = malha[i - 1]
        u_i = malha[i]
        u_p = malha[i + 1]
        malha[i] = novo_ui(alfaf,dt,rf,delta_rf,u_m,u_i,u_p,i,rhof,cpf,sno,b)

      if i == (nf - 1):
        malha[i] = (malha[i-1] * delta_rc * kf + malha[i+1] * delta_rf * kc) / (delta_rf * kc + delta_rc * kf)

      if (i >= nf) and (i <= (nf + nc - 3)):
        v_m = malha[i - 1]
        v_i = malha[i]
        v_p = malha[i + 1]
        malha[i] = novo_vi(alfac,dt,rf,rc,delta_rc,v_m,v_i,v_p,i,nf)

      if i == (nf + nc - 2):
        malha[i] = to - (to - ti) * np.exp(-alfac * n * dt)

  # Definindo os títulos dos eixos
  plt.xlabel('r [mm]')
  plt.ylabel('T [°C]')

  # Definindo o título do gráfico
  plt.title('Perfil de temperatura para diferentes tempos após o ligamento do reator')

  # Adicionando uma legenda
  plt.legend()

  gravador.append(malha)
          
  end_time = time.time()
  
  execution_time = end_time - start_time

  print(f"O código demorou {execution_time:.6f} segundos para rodar.")
  
  plt.show()
  
  #return malha.tolist() , [gravador]
  return malha , gravador
  #return gravador


def permanente():
  #dados do problema
  [[kf,kc],[rhof,rhoc],[cpf,cpc],[alfaf,alfac],[rf,rc],[nf,nc],[delta_rf,delta_rc],dt,ti,to,sno,b] = [[7,237],[10970,2700],[240,900],[2.6587663324217565e-06,9.7530864197530864197530864197531e-5],[7e-2,1e-1],[71,31],[1e-3,1e-3],4e-3,25,280,1e6,2]

  malha_t = []
  
  for i in range(nf + nc -1):
    if i <= (nf - 1): #região do combustível
      t = ((sno * rf**2)/(6 * kf)) * ((1 - ((i * delta_rf) / rf)**2) + (((3 * b) / 10) * (1 - ((i * delta_rf) / rf)**4))) + ((sno * rf**2)/(3*kc)) * (1 + 0.6 * b) * (1 - (rf / rc)) + to
        
    else: #região do revestimento
      rci = rf + (i - nf) * delta_rc
      t = ((sno * rf**2) / (3 * kc)) * (1 + 0.6 * b) * ((rf / rci) - (rf / rc)) + to

    malha_t.append(t)

  return malha_t

sol_permanente = permanente()


#resultado do programa transiente para t = 1e5, ou seja, quando o sistema está tendendo ao equilíbrio
sol_transiente_1e5 = [471.12970570757255, 471.12970571353344, 471.0582482678329, 470.9390359049281, 470.7718936976985, 470.55657674816734, 470.2927701875138, 469.9800891760662, 469.61807890330266, 469.2062145878514, 468.74390147748994, 468.23047484914645, 467.66520000890404, 467.04727229198994, 466.37581706278627, 465.64988971482546, 464.86847567078945, 464.0304903825096, 463.1347793309723, 462.1801180263089, 461.165212007805, 460.08869684389646, 458.94913813216857, 457.74503149935646, 456.47480260134535, 455.1368071231696, 453.7293307790194, 452.25058931222947, 450.6987284952889, 449.0718241298372, 447.3678820466633, 445.5848381057061, 443.7205581960596, 441.7728382359619, 439.7394041728066, 437.6179119831366, 435.40594767264514, 433.1010272761747, 430.70059685771804, 428.20203251041727, 425.6026403565703, 422.899656547619, 420.0902472641607, 417.1715087159424, 414.14046714186117, 410.9940788099634, 407.72923001745096, 404.3427370906704, 400.8313463851232, 397.1917342854603, 393.4205072054829, 389.5142015881423, 385.46928390553927, 381.2821506589245, 376.9491283787039, 372.4664736244284, 367.83037298480326, 363.03694307768455, 358.0822305500777, 352.96221207813824, 347.6727943671766, 342.20981415164846, 336.569038195164, 330.74616329048337, 324.73681625951735, 318.536553953326, 312.1408632521196, 305.54516106525796, 298.74479433125674, 291.73504001778167, 284.51110512164223, 284.2977399617191, 284.0903850969895, 283.88879009861245, 283.69271825987516, 283.5019456690224, 283.3162603562591, 283.13546150809526, 282.9593587429104, 282.7877714422442, 282.6205281328747, 282.45746591524113, 282.2984299342054, 282.14327288853855, 281.9918545758661, 281.84404147011713, 281.6997063288005, 281.5587278276804, 281.4209902206469, 281.2863830227768, 281.1548007147615, 281.02614246703934, 280.90031188211736, 280.7772167536979, 280.6567688413457, 280.5388836595375, 280.4234802800351, 280.3104811466106, 280.19981190123065, 280.09140122088394, 279.9851806642969]

#comparação da solução permanente x o programa transiente para t = 1e5
erro = np.array([-0.08548417, -0.06167172, -0.06165686, -0.0616321 , -0.06159744,
       -0.06155287, -0.0614984 , -0.06143403, -0.06135976, -0.06127558,
       -0.0611815 , -0.06107751, -0.06096363, -0.06083984, -0.06070614,
       -0.06056255, -0.06040905, -0.06024565, -0.06007235, -0.05988915,
       -0.05969604, -0.05949303, -0.05928012, -0.05905731, -0.05882459,
       -0.05858197, -0.05832945, -0.05806703, -0.05779471, -0.05751249,
       -0.05722036, -0.05691834, -0.05660641, -0.05628458, -0.05595285,
       -0.05561122, -0.05525969, -0.05489826, -0.05452693, -0.0541457 ,
       -0.05375457, -0.05335354, -0.05294261, -0.05252178, -0.05209105,
       -0.05165042, -0.05119989, -0.05073947, -0.05026914, -0.04978892,
       -0.0492988 , -0.04879878, -0.04828886, -0.04776905, -0.04723934,
       -0.04669973, -0.04615022, -0.04559082, -0.04502152, -0.04444232,
       -0.04385323, -0.04325424, -0.04264536, -0.04202658, -0.04139791,
       -0.04075934, -0.04011088, -0.03945252, -0.03878427, -0.03810612,
       -0.03741809, -0.25078325, -0.24459242, -0.23857355, -0.23271958,
       -0.22702381, -0.22147992, -0.21608191, -0.2108241 , -0.2057011 ,
       -0.20070778, -0.19583929, -0.191091  , -0.18645851, -0.18193764,
       -0.1775244 , -0.17321499, -0.16900579, -0.16489335, -0.16087436,
       -0.15694568, -0.15310429, -0.14934732, -0.14567201, -0.14207574,
       -0.13855597, -0.13511029, -0.13173639, -0.12843204, -0.12519512,
       -0.12202359]) #portanto o programa de diferenças finitas está validado


'''
dados = main(86400)[1]
'''


'''
# Plotando seis curvas no mesmo gráfico
plt.plot(r, dados[0], label='t = 0h', color='r')
plt.plot(r, dados[1], label='t = 4h', color='g')
plt.plot(r, dados[2], label='t = 8h', color='b')
plt.plot(r, dados[3], label='t = 12h', color='y')
plt.plot(r, dados[4], label='t = 16h', color='c')
plt.plot(r, dados[5], label='t = 20h', color='m')
plt.plot(r, dados[6], label='t = 24h', color='k')

# Definindo os títulos dos eixos
plt.xlabel('r [mm]')
plt.ylabel('T [°C]')

# Definindo o título do gráfico
plt.title('Perfil de temperatura para diferentes tempos após o ligamento do reator')

# Adicionando uma legenda
plt.legend()


fig, axs = plt.subplots()

y_min, y_max = 0, 450

# Primeiro subplot
axs[0, 0].plot(r, dados[0], 'r')  # Plota em vermelho
axs[0, 0].set_title('t = 0 min')
axs[0, 0].set_ylim([y_min, y_max])
axs[0, 0].set_xlabel('r [mm]')
axs[0, 0].set_ylabel('Temperatura [°C]')


# Segundo subplot
axs[0, 1].plot(r, dados[1], 'g')  # Plota em verde
axs[0, 1].set_title('t = 2 min')
axs[0, 1].set_ylim([y_min, y_max])
axs[0, 1].set_xlabel('r [mm]')
axs[0, 1].set_ylabel('Temperatura [°C]')


# Terceiro subplot
axs[0, 2].plot(r, dados[2], 'g')  # Plota em verde
axs[0, 2].set_title('t = 4 min')
axs[0, 2].set_ylim([y_min, y_max])
axs[0, 2].set_xlabel('r [mm]')
axs[0, 2].set_ylabel('Temperatura [°C]')


# Quarto subplot
axs[1, 0].plot(r, dados[3], 'b')  # Plota em azul
axs[1, 0].set_title('t = 6 min')
axs[1, 0].set_ylim([y_min, y_max])
axs[1, 0].set_xlabel('r [mm]')
axs[1, 0].set_ylabel('Temperatura [°C]')


# Quinto subplot
axs[1, 1].plot(r, dados[4], 'y')  # Plota em amarelo
axs[1, 1].set_title('t = 8 min')
axs[1, 1].set_ylim([y_min, y_max])
axs[1, 1].set_xlabel('r [mm]')
axs[1, 1].set_ylabel('Temperatura [°C]')


# Sexto subplot
axs[1, 2].plot(r, dados[5], 'y')  # Plota em amarelo
axs[1, 2].set_title('t = 10 min')
axs[1, 2].set_ylim([y_min, y_max])
axs[1, 2].set_xlabel('r [mm]')
axs[1, 2].set_ylabel('Temperatura [°C]')


# Ajustando o espaçamento entre os subplots
plt.tight_layout()


# Mostrando o gráfico
plt.show()
'''

#plt.plot(r,sol_permanente)
#plt.show()






















  
